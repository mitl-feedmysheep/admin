name: CI/CD Admin

on:
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  build_and_deploy:
    name: Build and Deploy
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set DOCKER_CONFIG env
        run: echo "DOCKER_CONFIG=$HOME/.docker-github-actions" >> $GITHUB_ENV

      - name: Prepare Docker config
        run: |
          mkdir -p "$DOCKER_CONFIG"
          echo '{}' > "$DOCKER_CONFIG/config.json"

      - name: Inject Docker auth
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          AUTH=$(printf "%s" "$DOCKERHUB_USERNAME:$DOCKERHUB_TOKEN" | base64)
          jq -n --arg auth "$AUTH" '{auths:{"https://index.docker.io/v1/":{"auth":$auth}}}' > "$DOCKER_CONFIG/config.json"

      - name: Ensure buildx plugin available
        run: |
          # 정의: buildx는 Docker의 "CLI 플러그인"이라 DOCKER_CONFIG 경로 아래에서 탐색됨.
          # 개념: 지금은 DOCKER_CONFIG를 ~/.docker-github-actions로 바꿔서,
          #       기존 ~/.docker/cli-plugins/docker-buildx를 못 찾아 "buildx missing" 오류가 났음.
          # 결과: runner가 DOCKER_CONFIG를 써도 buildx를 정상 인식.
          mkdir -p "$DOCKER_CONFIG/cli-plugins"

          if [ -x "$HOME/.docker/cli-plugins/docker-buildx" ]; then
            cp "$HOME/.docker/cli-plugins/docker-buildx" "$DOCKER_CONFIG/cli-plugins/docker-buildx"
          elif [ -x "/opt/homebrew/lib/docker/cli-plugins/docker-buildx" ]; then
            cp "/opt/homebrew/lib/docker/cli-plugins/docker-buildx" "$DOCKER_CONFIG/cli-plugins/docker-buildx"
          elif command -v docker-buildx >/dev/null 2>&1; then
            cp "$(command -v docker-buildx)" "$DOCKER_CONFIG/cli-plugins/docker-buildx"
          else
            echo "docker-buildx plugin not found on runner" >&2
            exit 1
          fi

          chmod +x "$DOCKER_CONFIG/cli-plugins/docker-buildx"
          docker buildx version

      - name: Ensure BuildKit builder ready
        run: |
          # 정의: builder = BuildKit 데몬(컨테이너) + 캐시를 관리하는 빌드 실행 환경
          # 개념: buildx는 builder 단위로 캐시/플랫폼을 관리함. 없으면 생성/사용 설정이 필요.
          # 결과: Dockerfile의 --mount=type=cache가 동작하고, 빌드 캐시가 재사용됨.
          docker buildx create --name buildkit --use --driver docker-container 2>/dev/null || docker buildx use buildkit
          docker buildx inspect --bootstrap

      - name: Remove old images
        run: |
          # 이전 intotheheaven-admin 이미지 삭제 (latest 제외)
          docker images intotheheaven-admin --format '{{.Tag}}' | grep -v latest | xargs -I {} docker rmi intotheheaven-admin:{} 2>/dev/null || true

      - name: Build Docker image
        run: |
          docker buildx build \
            --builder buildkit \
            --load \
            -t intotheheaven-admin:${{ github.sha }} \
            -t intotheheaven-admin:latest \
            .

      # DockerHub push 비활성화 (필요시 주석 해제)
      # - name: Push to DockerHub
      #   run: |
      #     docker push ${{ secrets.DOCKER_IMAGE_ADMIN }}:${{ github.sha }}
      #     docker push ${{ secrets.DOCKER_IMAGE_ADMIN }}:latest

      - name: Install Doppler CLI
        run: |
          if ! command -v doppler &> /dev/null; then
            brew install dopplerhq/cli/doppler
          fi

      - name: Stop existing container
        run: docker rm -f intotheheaven-admin 2>/dev/null || true

      - name: Start container with Doppler env
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}
        run: |
          ENV_ARGS=$(doppler secrets download --no-file --format json | jq -r 'to_entries | map("-e " + .key + "=\"" + .value + "\"") | join(" ")')
          
          eval docker run -d \
            --name intotheheaven-admin \
            --restart unless-stopped \
            -p 3000:3000 \
            $ENV_ARGS \
            intotheheaven-admin:${{ github.sha }}

      - name: Health check
        run: |
          sleep 10
          curl -f http://localhost:3000 || exit 1
          echo "✅ Health check passed!"

      - name: Cleanup dangling images
        run: docker image prune -f
